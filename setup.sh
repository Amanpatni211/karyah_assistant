#!/bin/bash

# Get project name from directory name
PROJECT_NAME=$(basename $(pwd))
ENV_NAME=$(echo $PROJECT_NAME | tr '-' '_')

echo "Setting up project: $PROJECT_NAME"

# Ask about conda environment
read -p "Create a dedicated conda environment? (y/n): " CREATE_ENV
if [[ "$CREATE_ENV" == "y" ]]; then
    # Try to source conda activation script
    CONDA_BASE=$(conda info --base 2>/dev/null)
    if [[ -n "$CONDA_BASE" && -f "$CONDA_BASE/etc/profile.d/conda.sh" ]]; then
        source "$CONDA_BASE/etc/profile.d/conda.sh"
        echo "Sourced conda.sh from $CONDA_BASE" 
    elif [[ -f "$HOME/miniconda3/etc/profile.d/conda.sh" ]]; then
        source "$HOME/miniconda3/etc/profile.d/conda.sh"
        echo "Sourced conda.sh from $HOME/miniconda3" 
    elif [[ -f "$HOME/anaconda3/etc/profile.d/conda.sh" ]]; then
        source "$HOME/anaconda3/etc/profile.d/conda.sh"
        echo "Sourced conda.sh from $HOME/anaconda3" 
    else
        echo "WARNING: Could not automatically source conda.sh. Assuming 'conda' command is available."
    fi
    
    echo "Creating conda environment: $ENV_NAME ..."
    conda create -y -n $ENV_NAME python=3.9
    conda activate $ENV_NAME
    
    # Install basic dependencies
    echo "Installing dependencies..."
    conda install -y numpy pandas matplotlib jupyter ipykernel
    
    echo "# Generated by conda environment creation" > environment.yml
    conda env export > environment.yml
    
    echo "Created conda environment: $ENV_NAME"
else
    echo "Skipping conda environment creation. Please install required packages manually."
fi

# Create modern ML project structure
mkdir -p src/$PROJECT_NAME/{data,models,utils,visualization}
mkdir -p notebooks tests configs data results docs

# Create __init__.py files to make the modules importable
touch src/$PROJECT_NAME/__init__.py
touch src/$PROJECT_NAME/data/__init__.py
touch src/$PROJECT_NAME/models/__init__.py
touch src/$PROJECT_NAME/utils/__init__.py
touch src/$PROJECT_NAME/visualization/__init__.py

# Create setup.py for easier importing
cat > setup.py << EOL
from setuptools import setup, find_packages

setup(
    name="$PROJECT_NAME",
    version="0.1",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
)
EOL

# Create basic files
touch requirements.txt
cat > requirements.txt << EOL
# Core Data Science
numpy
pandas
matplotlib
scikit-learn

# Notebooks
jupyter
ipykernel

# Development
pytest
black
flake8

# Add your additional requirements here
EOL

# Create README with better documentation
cat > README.md << EOL
# $PROJECT_NAME

## Setup

*This setup assumes you have already cloned the repository or created the project locally.*

\`\`\`bash
cd $PROJECT_NAME # Navigate to project directory if not already there

# Option 1: Create and activate conda environment (Recommended)
# (Run this if you didn't create the environment during initial setup)
conda env create -f environment.yml
conda activate $ENV_NAME

# Option 2: Install in existing environment
# Ensure your current environment has the necessary packages
pip install -e .
pip install -r requirements.txt
\`\`\`

## Project Structure
\`\`\`
├── configs/          # Configuration files
├── data/             # Raw and processed data (not in Git)
├── docs/             # Documentation
├── notebooks/        # Jupyter notebooks
├── results/          # Output of experiments (not in Git)
├── src/              # Source code
│   └── $PROJECT_NAME/
│       ├── data/     # Data processing
│       ├── models/   # ML models
│       ├── utils/    # Utilities
│       └── visualization/ # Plotting and visualization
└── tests/            # Unit tests
\`\`\`

## License
Copyright (c) $(date +%Y) [Your Name/Organization]
EOL

# Initialize git repository if it doesn't exist (for local-only scenario)
if [ ! -d .git ]; then
    git init
    echo "Initialized local git repository."
fi

# Add common ignores to .gitignore
echo "\n# Standard Python ignores\n__pycache__/\n*.pyc\n*.pyo\n*.pyd\n*.egg-info/\ndist/\nbuild/\n\n# Data & Results\ndata/\nresults/\n\n# IDE & Environment specific\n.vscode/\n.idea/\n.ipynb_checkpoints/\n\n# Secrets\n*.env\n" >> .gitignore

# Create config template
mkdir -p configs
cat > configs/default.yml << EOL
# Project configuration
project_name: $PROJECT_NAME
data_path: data/
results_path: results/
EOL

# Create example notebook
mkdir -p notebooks
cat > notebooks/01_exploration.ipynb << EOL
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# $PROJECT_NAME: Data Exploration\n",
    "Created: $(date)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "source": [
    "import sys\n",
    "sys.path.append(\"..\")\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Import project modules\n",
    "try:\n",
    "  from src.$PROJECT_NAME.utils import config\n",
    "  CFG = config.load_config(\"../configs/default.yml\")\n",
    "  print(\"Config loaded:\", CFG)\n",
    "except ImportError:\n",
    "  print(\"Could not import project modules. Ensure setup.py is installed (-e .)\")\n",
    "\n",
    "%matplotlib inline"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
EOL

# Create a simple utility module for configuration
mkdir -p src/$PROJECT_NAME/utils
cat > src/$PROJECT_NAME/utils/config.py << EOL
"""Configuration utilities."""
import os
import yaml

def load_config(config_path="configs/default.yml"):
    """Load configuration from YAML file."""
    # Adjust path relative to this file's location if needed
    # script_dir = os.path.dirname(__file__)
    # config_abs_path = os.path.join(script_dir, "../..", config_path)
    # Use absolute path if running from different directories
    config_abs_path = os.path.abspath(config_path) 
    
    if not os.path.exists(config_abs_path):
        print(f"Warning: Config file not found at {config_abs_path}")
        # Try path relative to potential project root if setup.py was used
        alt_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../..", config_path))
        if os.path.exists(alt_path):
            config_abs_path = alt_path
        else:
            print(f"Warning: Also not found at {alt_path}. Returning empty config.")
            return {}

    with open(config_abs_path, "r") as f:
        return yaml.safe_load(f)
EOL

echo "Project setup complete!" 